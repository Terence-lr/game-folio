<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gamefolio - Underwater Portfolio</title>
    <meta name="description" content="Navigate an immersive 3D underwater world to explore Terence Richardson's portfolio projects and skills">
    <meta name="keywords" content="portfolio, 3D, underwater, Three.js, interactive, developer, Terence Richardson">
    <meta name="author" content="Terence Richardson">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://gamefolio.vercel.app/">
    <meta property="og:title" content="Gamefolio - Underwater Portfolio">
    <meta property="og:description" content="Navigate an immersive 3D underwater world to explore Terence Richardson's portfolio projects and skills">
    <meta property="og:image" content="https://gamefolio.vercel.app/favicon.svg">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://gamefolio.vercel.app/">
    <meta property="twitter:title" content="Gamefolio - Underwater Portfolio">
    <meta property="twitter:description" content="Navigate an immersive 3D underwater world to explore Terence Richardson's portfolio projects and skills">
    <meta property="twitter:image" content="https://gamefolio.vercel.app/favicon.svg">

    <!-- Preconnect to CDNs for performance -->
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    
    <style>
        /* Basic Reset */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #050a1a; /* Deep blue background */
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Prevents default browser gestures like pull-to-refresh */
        }

        /* Three.js Canvas */
        #bg {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }

        /* UI Elements */
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the canvas */
            z-index: 10;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Hidden on desktop */
            pointer-events: auto; /* Re-enable pointer events for controls */
        }
        
        #joystick-container {
            position: absolute;
            bottom: 25px;
            left: 25px;
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        #joystick-thumb {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
        }

        #boost-button {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 80px;
            height: 80px;
            background-color: rgba(220, 53, 69, 0.5); /* Crimson accent */
            border-radius: 50%;
            border: 2px solid rgba(220, 53, 69, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: white;
            user-select: none;
            transition: transform 0.1s ease, background-color 0.1s ease;
        }
        #boost-button:active {
            transform: scale(0.95);
            background-color: rgba(255, 80, 95, 0.7);
        }

        #depth-controls {
            position: absolute;
            right: 35px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .depth-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: white;
            font-size: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            transition: background-color 0.1s ease;
        }

        .depth-button:active {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        /* Instruction / Portfolio Pop-up */
        .info-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 25, 47, 0.85);
            padding: 25px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            max-width: 90%;
            width: 350px;
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            pointer-events: auto;
        }
        
        .info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .info-panel h2 {
            margin-top: 0;
            color: #e6f1ff;
        }
        
        .info-panel p {
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .info-panel button {
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .info-panel button:hover {
            background-color: #c82333;
        }
        
        #portfolio-link {
            text-decoration: none;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #050a1a 0%, #0a1a2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #dc3545;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #e6f1ff;
            font-size: 1.2rem;
            font-weight: 500;
        }
        
        /* Show mobile controls only on touch devices */
        @media (pointer: coarse) {
            #mobile-controls {
                display: block;
            }
        }

        /* Speed indicator */
        .speed-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
        }

        /* Start Screen Overlay */
        .start-screen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a2e 0%, #1a3a5c 50%, #2d5016 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease-out;
            pointer-events: auto;
            /* 8-bit inspired pixelated effect */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .start-screen-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .start-screen-content {
            text-align: center;
            color: white;
            max-width: 600px;
            padding: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            border: 2px solid rgba(135, 206, 235, 0.3);
            backdrop-filter: blur(10px);
        }

        .start-title {
            font-size: 3.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #87ceeb, #98d8e8, #a8e6cf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(135, 206, 235, 0.5);
            /* 8-bit inspired styling */
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            border: 3px solid #87ceeb;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            box-shadow: 0 0 30px rgba(135, 206, 235, 0.3);
            letter-spacing: 3px;
        }

        .start-subtitle {
            font-size: 1.2rem;
            color: #98d8e8;
            margin-bottom: 30px;
        }

        .start-character-info,
        .start-controls-guide,
        .start-billboard-info {
            margin: 25px 0;
            padding: 20px;
            background: rgba(26, 58, 92, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(135, 206, 235, 0.2);
        }

        .start-character-info h3,
        .start-controls-guide h3,
        .start-billboard-info h3 {
            color: #87ceeb;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }
        
        /* 8-bit Pixel Character */
        .pixel-character {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 15px 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .pixel-head {
            width: 20px;
            height: 20px;
            background: #6b7280;
            border: 2px solid #4a4a4a;
            margin-bottom: 2px;
        }
        
        .pixel-body {
            width: 24px;
            height: 30px;
            background: #6b7280;
            border: 2px solid #4a4a4a;
            margin-bottom: 2px;
        }
        
        .pixel-arms {
            width: 40px;
            height: 8px;
            background: #6b7280;
            border: 2px solid #4a4a4a;
            margin-bottom: 2px;
        }
        
        .pixel-legs {
            width: 32px;
            height: 20px;
            background: #4a4a4a;
            border: 2px solid #2a2a2a;
        }

        .controls-visual {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border: 1px solid rgba(135, 206, 235, 0.3);
        }

        .control-key {
            background: linear-gradient(45deg, #4a90e2, #87ceeb);
            color: white;
            padding: 8px 12px;
            border-radius: 0px; /* 8-bit square corners */
            font-weight: bold;
            font-size: 0.9rem;
            min-width: 50px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(74, 144, 226, 0.3);
            /* 8-bit inspired styling */
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            border: 2px solid #87ceeb;
            text-shadow: 1px 1px 0px rgba(0, 0, 0, 0.5);
        }

        .enter-world-btn {
            background: linear-gradient(45deg, #4a90e2, #87ceeb);
            color: white;
            border: 3px solid #87ceeb;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 0px; /* 8-bit square corners */
            cursor: pointer;
            margin-top: 30px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(74, 144, 226, 0.4);
            pointer-events: auto;
            z-index: 1001;
            position: relative;
            /* 8-bit inspired styling */
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5);
        }

        .enter-world-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(74, 144, 226, 0.6);
            background: linear-gradient(45deg, #87ceeb, #98d8e8);
        }

        /* Performance optimizations */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Reduce motion for users who prefer it */
        @media (prefers-reduced-motion: reduce) {
            .info-panel, .loading-screen {
                transition: none;
            }
            .loading-spinner {
                animation: none;
            }
        }
    </style>
</head>
<body>

    <canvas id="bg"></canvas>

    <div class="ui-overlay">
        
        <div class="speed-indicator" id="speed-indicator">
            Speed: 0 | Boost: OFF
        </div>
        
        <div id="mobile-controls">
            <div id="joystick-container">
                <div id="joystick-thumb"></div>
            </div>
            <div id="boost-button">BOOST</div>
            <div id="depth-controls">
                <div id="depth-up-button" class="depth-button">▲</div>
                <div id="depth-down-button" class="depth-button">▼</div>
            </div>
        </div>
        
        
        <div id="start-screen-overlay" class="start-screen-overlay visible">
            <div class="start-screen-content">
                <h1 class="start-title">GAMEFOLIO</h1>
                <p class="start-subtitle">Interactive 3D Portfolio Experience</p>
                
                <div class="start-character-info">
                    <h3>Your Character</h3>
                    <div class="pixel-character">
                        <div class="pixel-head"></div>
                        <div class="pixel-body"></div>
                        <div class="pixel-arms"></div>
                        <div class="pixel-legs"></div>
                    </div>
                    <p>You are the explorer in this starry night world. Use the controls below to navigate through my portfolio projects.</p>
                </div>
                
                <div class="start-controls-guide">
                    <h3>Controls</h3>
                    <div class="controls-visual">
                        <div class="control-row">
                            <div class="control-key">W</div>
                            <span>Forward</span>
                        </div>
                        <div class="control-row">
                            <div class="control-key">S</div>
                            <span>Backward</span>
                        </div>
                        <div class="control-row">
                            <div class="control-key">A</div>
                            <span>Left</span>
                        </div>
                        <div class="control-row">
                            <div class="control-key">D</div>
                            <span>Right</span>
                        </div>
                        <div class="control-row">
                            <div class="control-key">Q</div>
                            <span>Up</span>
                        </div>
                        <div class="control-row">
                            <div class="control-key">E</div>
                            <span>Down</span>
                        </div>
                        <div class="control-row">
                            <div class="control-key">SPACE</div>
                            <span>Boost</span>
                        </div>
                    </div>
                </div>
                
                <div class="start-billboard-info">
                    <h3>Interactive Billboards</h3>
                    <p>Explore the glowing billboards to discover my projects. Each one represents a different portfolio piece with detailed information.</p>
                </div>
                
                <button id="enter-world-button" class="enter-world-btn">Enter World</button>
            </div>
        </div>
        
        <div id="portfolio-info-panel" class="info-panel">
            <h2 id="portfolio-title">Portfolio Section</h2>
            <p id="portfolio-description">This is where the project description will go.</p>
            <a id="portfolio-link" href="#" target="_blank" rel="noopener noreferrer">
                <button>Visit Project</button>
            </a>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x0a0a2e, 0.005); // Deep blue night fog
        
        // Start screen flag
        let showStartScreen = true;

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);
        
        // Add a simple start screen indicator
        console.log('Start screen initialized, showStartScreen:', showStartScreen);
        
        // Set initial camera position for start screen
        if (showStartScreen) {
            camera.position.set(0, 2, 10);
            camera.lookAt(0, 0, 0);
        }

        // Font loading for 3D text
        const fontLoader = new FontLoader();
        let font = null;
        
        fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
            font = loadedFont;
            console.log('Font loaded successfully');
        });

        // --- START SCREEN SETUP ---
        const startScreenGroup = new THREE.Group();
        
        // Start screen ground
        const startGroundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a3a5c,
            roughness: 0.8,
            metalness: 0.1
        });
        
        const startGround = new THREE.Mesh(
            new THREE.BoxGeometry(30, 1, 30),
            startGroundMaterial
        );
        startGround.position.y = -1;
        startGround.receiveShadow = true;
        startScreenGroup.add(startGround);
        
        // Start screen grass patches
        const startGrassMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d5016,
            roughness: 0.8,
            metalness: 0.0
        });
        
        for (let i = 0; i < 15; i++) {
            const grass = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.3, 0.8, 6),
                startGrassMaterial
            );
            grass.position.set(
                (Math.random() - 0.5) * 25,
                0.4,
                (Math.random() - 0.5) * 25
            );
            grass.rotation.z = (Math.random() - 0.5) * 0.3;
            grass.castShadow = true;
            grass.receiveShadow = true;
            startScreenGroup.add(grass);
        }
        
        // Start screen trees
        const startTrunkMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3a3a3a,
            roughness: 0.8,
            metalness: 0.1
        });
        
        for (let i = 0; i < 6; i++) {
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.4, 4, 6),
                startTrunkMaterial
            );
            trunk.position.set(
                (Math.random() - 0.5) * 20,
                2,
                (Math.random() - 0.5) * 20
            );
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            startScreenGroup.add(trunk);
            
            const treeTop = new THREE.Mesh(
                new THREE.SphereGeometry(2, 6, 4),
                new THREE.MeshStandardMaterial({ 
                    color: 0x98d8e8,
                    roughness: 0.3,
                    metalness: 0.2,
                    emissive: 0x1a3a5c,
                    emissiveIntensity: 0.2
                })
            );
            treeTop.position.set(
                trunk.position.x,
                5,
                trunk.position.z
            );
            treeTop.castShadow = true;
            treeTop.receiveShadow = true;
            startScreenGroup.add(treeTop);
        }
        
        // Start screen billboard
        const startBillboardGroup = new THREE.Group();
        
        // Billboard frame
        const startFrameMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2a2a2a, 
            metalness: 0.8, 
            roughness: 0.2 
        });
        
        const startFrame = new THREE.Mesh(new THREE.BoxGeometry(8, 5, 0.2), startFrameMaterial);
        startFrame.position.y = 2.5;
        startFrame.castShadow = true;
        startFrame.receiveShadow = true;
        startBillboardGroup.add(startFrame);
        
        // Billboard screen
        const startScreenMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a90e2, 
            metalness: 0.1, 
            roughness: 0.3,
            emissive: 0x4a90e2,
            emissiveIntensity: 0.2
        });
        
        const startScreen = new THREE.Mesh(new THREE.BoxGeometry(7.5, 4.5, 0.1), startScreenMaterial);
        startScreen.position.y = 2.5;
        startScreen.position.z = 0.1;
        startBillboardGroup.add(startScreen);
        
        // Billboard stand
        const startStandMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a1a, 
            metalness: 0.6, 
            roughness: 0.4 
        });
        
        const startStand = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 2.5, 8), startStandMaterial);
        startStand.position.y = 1.25;
        startStand.castShadow = true;
        startStand.receiveShadow = true;
        startBillboardGroup.add(startStand);
        
        // Billboard light
        const startBillboardLight = new THREE.PointLight(0x4a90e2, 4, 25);
        startBillboardLight.position.y = 4;
        startBillboardGroup.add(startBillboardLight);
        
        startBillboardGroup.position.set(0, 0, -8);
        startScreenGroup.add(startBillboardGroup);
        
        // Start screen character (person)
        const startPersonGroup = new THREE.Group();
        
        const startPersonMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x6b7280,
            metalness: 0.2,
            roughness: 0.7
        });
        
        // Head
        const startHead = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 8, 6),
            startPersonMaterial
        );
        startHead.position.y = 1.2;
        startHead.castShadow = true;
        startPersonGroup.add(startHead);
        
        // Body
        const startBody = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 1.0, 0.4),
            startPersonMaterial
        );
        startBody.position.y = 0.3;
        startBody.castShadow = true;
        startPersonGroup.add(startBody);
        
        // Arms
        const startLeftArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            startPersonMaterial
        );
        startLeftArm.position.set(-0.5, 0.2, 0);
        startLeftArm.castShadow = true;
        startPersonGroup.add(startLeftArm);
        
        const startRightArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            startPersonMaterial
        );
        startRightArm.position.set(0.5, 0.2, 0);
        startRightArm.castShadow = true;
        startPersonGroup.add(startRightArm);
        
        // Legs
        const startLegMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a4a4a,
            metalness: 0.1,
            roughness: 0.8
        });
        
        const startLeftLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            startLegMaterial
        );
        startLeftLeg.position.set(-0.2, -0.6, 0);
        startLeftLeg.castShadow = true;
        startPersonGroup.add(startLeftLeg);
        
        const startRightLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            startLegMaterial
        );
        startRightLeg.position.set(0.2, -0.6, 0);
        startRightLeg.castShadow = true;
        startPersonGroup.add(startRightLeg);
        
        // Eyes
        const startEyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const startLeftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), startEyeMaterial);
        startLeftEye.position.set(-0.1, 1.3, 0.3);
        startPersonGroup.add(startLeftEye);
        
        const startRightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), startEyeMaterial);
        startRightEye.position.set(0.1, 1.3, 0.3);
        startPersonGroup.add(startRightEye);
        
        startPersonGroup.position.set(0, 0, 5);
        startScreenGroup.add(startPersonGroup);
        
        // Start screen particles
        const startParticleCount = 20;
        const startParticleGeometry = new THREE.BufferGeometry();
        const startParticlePositions = new Float32Array(startParticleCount * 3);
        const startParticleSizes = new Float32Array(startParticleCount);
        
        for (let i = 0; i < startParticleCount; i++) {
            startParticlePositions[i * 3] = (Math.random() - 0.5) * 30;
            startParticlePositions[i * 3 + 1] = Math.random() * 8 + 2;
            startParticlePositions[i * 3 + 2] = (Math.random() - 0.5) * 30;
            startParticleSizes[i] = Math.random() * 0.4 + 0.2;
        }
        
        startParticleGeometry.setAttribute('position', new THREE.BufferAttribute(startParticlePositions, 3));
        startParticleGeometry.setAttribute('size', new THREE.BufferAttribute(startParticleSizes, 1));
        
        const startParticles = new THREE.Points(startParticleGeometry, new THREE.PointsMaterial({
            color: 0x87ceeb,
            size: 0.5,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        }));
        startScreenGroup.add(startParticles);
        
        // Add lighting for start screen
        const startAmbientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(startAmbientLight);
        
        const startDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        startDirectionalLight.position.set(10, 10, 5);
        scene.add(startDirectionalLight);
        
        scene.add(startScreenGroup);

        // --- MAIN WORLD GROUP (initially hidden) ---
        const mainWorldGroup = new THREE.Group();
        mainWorldGroup.visible = false;

        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector('#bg'),
            antialias: true,
            powerPreference: 'high-performance',
            alpha: false,
            preserveDrawingBuffer: false
        });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.4; // Increased exposure for better underwater feel
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        // --- PERFORMANCE OPTIMIZATIONS (Inspired by create-3d-worlds) ---
        
        // Enable frustum culling for better performance
        renderer.frustumCulled = true;
        
        // Optimize shadow rendering
        renderer.shadowMap.autoUpdate = false;
        renderer.shadowMap.needsUpdate = true;
        
        // Performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;
        
        // LOD (Level of Detail) system for distant objects
        const lodObjects = [];
        function updateLOD() {
            lodObjects.forEach(obj => {
                const distance = camera.position.distanceTo(obj.position);
                if (distance > 50) {
                    obj.visible = false;
                } else if (distance > 30) {
                    obj.scale.setScalar(0.5);
                } else {
                    obj.scale.setScalar(1.0);
                    obj.visible = true;
                }
            });
        }
        
        // --- POST-PROCESSING EFFECTS (Three.js Examples Inspired) ---
        const composer = new EffectComposer(renderer);
        
        // Render pass
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        
        // Bloom effect for magical glow
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, // strength
            0.4, // radius
            0.85 // threshold
        );
        composer.addPass(bloomPass);
        
        // Enhanced GLSL shader inspired by glsl-sandbox
        const nightShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'time': { value: 0.0 },
                'intensity': { value: 0.3 },
                'resolution': { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float intensity;
                uniform vec2 resolution;
                varying vec2 vUv;
                
                // Noise function inspired by glsl-sandbox
                float noise(vec2 p) {
                    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                }
                
                // Aurora effect inspired by glsl-sandbox
                float aurora(vec2 uv, float time) {
                    float a = 0.0;
                    for(int i = 0; i < 3; i++) {
                        float f = float(i + 1) * 0.1;
                        a += sin(uv.x * f + time * 0.5) * cos(uv.y * f + time * 0.3) * 0.1;
                    }
                    return a;
                }
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Enhanced color grading for night atmosphere
                    color.rgb = mix(color.rgb, color.rgb * vec3(0.8, 0.9, 1.2), intensity);
                    
                    // Add aurora effect
                    vec2 uv = vUv * 2.0 - 1.0;
                    uv.x *= resolution.x / resolution.y;
                    float auroraEffect = aurora(uv, time);
                    color.rgb += vec3(0.0, auroraEffect * 0.3, auroraEffect * 0.5);
                    
                    // Enhanced film grain with better noise
                    float grain = noise(vUv + time * 0.1) - 0.5;
                    color.rgb += grain * 0.02;
                    
                    // Subtle vignette effect
                    float vignette = 1.0 - length(vUv - 0.5) * 0.8;
                    color.rgb *= vignette;
                    
                    gl_FragColor = color;
                }
            `
        };
        
        const nightPass = new ShaderPass(nightShader);
        composer.addPass(nightPass);

        // --- CAMERA CONTROLS ---
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let controls;
        if (!isMobile) {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.enablePan = false;
            controls.minDistance = 5;
            controls.maxDistance = 20;
            controls.target.set(0, 0, 0); // Camera will orbit a central point
        }
        
        // --- INTERACTIVE RAYCASTING (Three.js Examples Inspired) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObject = null;
        
        // Mouse interaction for billboards
        function onMouseMove(event) {
            if (showStartScreen) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(portfolioItems.map(item => item.mesh));
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                if (hoveredObject !== intersected) {
                    // Reset previous hover
                    if (hoveredObject) {
                        hoveredObject.scale.setScalar(1.0);
                    }
                    
                    // Set new hover
                    hoveredObject = intersected;
                    hoveredObject.scale.setScalar(1.1);
                    
                    // Change cursor
                    document.body.style.cursor = 'pointer';
                }
            } else {
                if (hoveredObject) {
                    hoveredObject.scale.setScalar(1.0);
                    hoveredObject = null;
                    document.body.style.cursor = 'default';
                }
            }
        }
        
        // Click interaction for billboards
        function onMouseClick(event) {
            if (showStartScreen) return;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(portfolioItems.map(item => item.mesh));
            
            if (intersects.length > 0) {
                const intersected = intersects[0].object;
                const portfolioItem = portfolioItems.find(item => item.mesh === intersected);
                if (portfolioItem) {
                    window.open(portfolioItem.link, '_blank');
                }
            }
        }
        
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('click', onMouseClick);

        // --- ADVANCED STARRY NIGHT LIGHTING (Three.js Examples Inspired) ---
        // Cool ambient light for night atmosphere
        const ambientLight = new THREE.AmbientLight(0x1a1a3a, 0.4);
        scene.add(ambientLight);
        
        // Hemisphere light for natural sky/ground lighting
        const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x2d5016, 0.3);
        scene.add(hemisphereLight);
        
        // Enhanced moonlight (soft directional light)
        const moonLight = new THREE.DirectionalLight(0x87ceeb, 0.8);
        moonLight.position.set(5, 30, 10);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 4096;
        moonLight.shadow.mapSize.height = 4096;
        moonLight.shadow.camera.near = 0.5;
        moonLight.shadow.camera.far = 100;
        moonLight.shadow.camera.left = -30;
        moonLight.shadow.camera.right = 30;
        moonLight.shadow.camera.top = 30;
        moonLight.shadow.camera.bottom = -30;
        moonLight.shadow.bias = -0.0001;
        scene.add(moonLight);
        
        // Dynamic star lights with color variation
        const starLights = [];
        const starColors = [0x87ceeb, 0x98d8e8, 0xa8e6cf, 0xff6b9d, 0x4ecdc4];
        const starPositions = [
            [-15, 8, -15], [15, 6, 15], [0, 10, -20], 
            [20, 6, 0], [-10, 15, 10], [5, 8, -25]
        ];
        
        starPositions.forEach((pos, index) => {
            const starLight = new THREE.PointLight(
                starColors[index % starColors.length], 
                1.2 + Math.random() * 0.8, 
                25 + Math.random() * 15
            );
            starLight.position.set(pos[0], pos[1], pos[2]);
            starLight.castShadow = true;
            starLight.shadow.mapSize.width = 1024;
            starLight.shadow.mapSize.height = 1024;
            scene.add(starLight);
            starLights.push(starLight);
        });
        
        // Volumetric lighting (god rays effect)
        const volumetricLight = new THREE.SpotLight(0x87ceeb, 2.0, 50, Math.PI / 6, 0.3, 1);
        volumetricLight.position.set(0, 25, 0);
        volumetricLight.target.position.set(0, 0, 0);
        volumetricLight.castShadow = true;
        scene.add(volumetricLight);
        scene.add(volumetricLight.target);

        // --- GOD RAYS (VOLUMETRIC LIGHTING EFFECT) ---
        const godraysEffect = new THREE.Group();
        const textureLoader = new THREE.TextureLoader();
        
        // Create a simple procedural texture for god rays
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 256);
        
        const godrayTexture = new THREE.CanvasTexture(canvas);
        godrayTexture.wrapS = THREE.RepeatWrapping;
        godrayTexture.wrapT = THREE.RepeatWrapping;
        
        const godrayMaterial = new THREE.MeshBasicMaterial({
            map: godrayTexture,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
            opacity: 0.15
        });

        for (let i = 0; i < 5; i++) {
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(150, 150), godrayMaterial);
            plane.position.set(
                (Math.random() - 0.5) * 50,
                20,
                (Math.random() - 0.5) * 50
            );
            plane.rotation.x = -Math.PI / 2;
            plane.rotation.z = Math.random() * Math.PI;
            godraysEffect.add(plane);
        }
        scene.add(godraysEffect);

        // --- NATURAL NIGHT ENVIRONMENT ---
        // Main ground with grass texture
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d5016,
            roughness: 0.9,
            metalness: 0.0
        });
        
        // Main ground platform
        const mainGround = new THREE.Mesh(
            new THREE.BoxGeometry(50, 1, 50),
            groundMaterial
        );
        mainGround.position.y = -1;
        mainGround.receiveShadow = true;
        mainWorldGroup.add(mainGround);
        
        // --- PROCEDURAL ENVIRONMENT GENERATION (Inspired by create-3d-worlds) ---
        
        // Procedural terrain generation
        function generateProceduralTerrain() {
            const terrainGeometry = new THREE.PlaneGeometry(100, 100, 64, 64);
            const vertices = terrainGeometry.attributes.position.array;
            
            // Add height variation using noise
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                const height = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2 + 
                              Math.sin(x * 0.05) * Math.cos(z * 0.05) * 4;
                vertices[i + 1] = height;
            }
            
            terrainGeometry.attributes.position.needsUpdate = true;
            terrainGeometry.computeVertexNormals();
            
            const terrainMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d5016,
                roughness: 0.8,
                metalness: 0.1,
                wireframe: false
            });
            
            const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            terrain.position.y = -2;
            terrain.receiveShadow = true;
            terrain.castShadow = true;
            mainWorldGroup.add(terrain);
            
            return terrain;
        }
        
        // Generate procedural terrain
        const proceduralTerrain = generateProceduralTerrain();
        
        // Add terrain to LOD system
        lodObjects.push(proceduralTerrain);
        
        // --- PROCEDURAL OBJECT GENERATION (create-3d-worlds inspired) ---
        
        // Generate procedural rocks and crystals
        function generateProceduralObjects() {
            const objects = [];
            const objectCount = 20;
            
            for (let i = 0; i < objectCount; i++) {
                const x = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 80;
                const y = Math.random() * 3 + 1;
                
                // Random object type
                const objectType = Math.random();
                let object;
                
                if (objectType < 0.3) {
                    // Crystal
                    object = new THREE.Mesh(
                        new THREE.ConeGeometry(0.5 + Math.random() * 1, 2 + Math.random() * 2, 6),
                        new THREE.MeshStandardMaterial({ 
                            color: new THREE.Color().setHSL(0.6 + Math.random() * 0.2, 0.8, 0.6),
                            metalness: 0.8,
                            roughness: 0.2,
                            emissive: new THREE.Color().setHSL(0.6 + Math.random() * 0.2, 0.8, 0.3),
                            emissiveIntensity: 0.2
                        })
                    );
                } else if (objectType < 0.6) {
                    // Rock
                    object = new THREE.Mesh(
                        new THREE.SphereGeometry(0.5 + Math.random() * 1, 8, 6),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x4a4a4a,
                            roughness: 0.9,
                            metalness: 0.1
                        })
                    );
                } else {
                    // Tree
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.3, 2 + Math.random() * 2, 6),
                        new THREE.MeshStandardMaterial({ color: 0x3a3a3a })
                    );
                    const leaves = new THREE.Mesh(
                        new THREE.SphereGeometry(1 + Math.random(), 6, 4),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x4a7c59,
                            emissive: 0x1a3a5c,
                            emissiveIntensity: 0.1
                        })
                    );
                    leaves.position.y = 1.5;
                    
                    object = new THREE.Group();
                    object.add(trunk);
                    object.add(leaves);
                }
                
                object.position.set(x, y, z);
                object.castShadow = true;
                object.receiveShadow = true;
                object.rotation.y = Math.random() * Math.PI * 2;
                
                mainWorldGroup.add(object);
                objects.push(object);
                lodObjects.push(object);
            }
            
            return objects;
        }
        
        // Generate procedural objects
        const proceduralObjects = generateProceduralObjects();
        
        // Enhanced water body with reflections
        const waterMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1e3a8a,
            roughness: 0.0,
            metalness: 1.0,
            transparent: true,
            opacity: 0.9,
            envMapIntensity: 1.0
        });
        
        const water = new THREE.Mesh(
            new THREE.CylinderGeometry(8, 8, 0.2, 32),
            waterMaterial
        );
        water.position.set(-20, 0, -20);
        water.rotation.x = -Math.PI / 2;
        water.receiveShadow = true;
        water.castShadow = true;
        mainWorldGroup.add(water);
        
        // Water ripples effect
        const rippleGeometry = new THREE.RingGeometry(0.5, 8, 16);
        const rippleMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        
        for (let i = 0; i < 5; i++) {
            const ripple = new THREE.Mesh(rippleGeometry, rippleMaterial);
            ripple.position.set(-20, 0.1, -20);
            ripple.rotation.x = -Math.PI / 2;
            ripple.scale.set(0.1, 0.1, 0.1);
            mainWorldGroup.add(ripple);
        }
        
        // Grass patches
        const grassMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a7c59,
            roughness: 0.8,
            metalness: 0.0
        });
        
        for (let i = 0; i < 20; i++) {
            const grass = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.3, 0.8, 6),
                grassMaterial
            );
            grass.position.set(
                (Math.random() - 0.5) * 40,
                0.4,
                (Math.random() - 0.5) * 40
            );
            grass.rotation.z = (Math.random() - 0.5) * 0.3;
            grass.castShadow = true;
            grass.receiveShadow = true;
            mainWorldGroup.add(grass);
        }
        
        // Night-themed decorative objects
        const rockMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a4a4a,
            roughness: 0.8,
            metalness: 0.1
        });
        
        // Rocks scattered around
        for (let i = 0; i < 12; i++) {
            const rock = new THREE.Mesh(
                new THREE.SphereGeometry(
                    Math.random() * 1.5 + 0.5,
                    8, 6
                ), 
                rockMaterial
            );
            rock.position.set(
                (Math.random() - 0.5) * 35,
                Math.random() * 1,
                (Math.random() - 0.5) * 35
            );
            rock.scale.set(
                1 + Math.random() * 0.5,
                0.5 + Math.random() * 0.8,
                1 + Math.random() * 0.5
            );
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.castShadow = true;
            rock.receiveShadow = true;
            mainWorldGroup.add(rock);
        }
        
        // Glowing crystals
        const crystalMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x87ceeb,
            roughness: 0.2,
            metalness: 0.8,
            emissive: 0x1a3a5c,
            emissiveIntensity: 0.3
        });
        
        for (let i = 0; i < 6; i++) {
            const crystal = new THREE.Mesh(
                new THREE.ConeGeometry(0.8, 2, 6),
                crystalMaterial
            );
            crystal.position.set(
                (Math.random() - 0.5) * 25,
                1,
                (Math.random() - 0.5) * 25
            );
            crystal.rotation.y = Math.random() * Math.PI;
            crystal.castShadow = true;
            crystal.receiveShadow = true;
            mainWorldGroup.add(crystal);
        }
        
        // Night trees with glowing leaves
        const trunkMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x3a3a3a,
            roughness: 0.8,
            metalness: 0.1
        });
        
        for (let i = 0; i < 8; i++) {
            // Tree trunk
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.4, 4, 6),
                trunkMaterial
            );
            trunk.position.set(
                (Math.random() - 0.5) * 30,
                2,
                (Math.random() - 0.5) * 30
            );
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            mainWorldGroup.add(trunk);
            
            // Glowing tree top
            const treeTop = new THREE.Mesh(
                new THREE.SphereGeometry(2, 6, 4),
                new THREE.MeshStandardMaterial({ 
                    color: 0x98d8e8,
                    roughness: 0.3,
                    metalness: 0.2,
                    emissive: 0x1a3a5c,
                    emissiveIntensity: 0.2
                })
            );
            treeTop.position.set(
                trunk.position.x,
                5,
                trunk.position.z
            );
            treeTop.castShadow = true;
            treeTop.receiveShadow = true;
            mainWorldGroup.add(treeTop);
        }
        
        // Glowing mushrooms
        const mushroomMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xa8e6cf,
            roughness: 0.6,
            metalness: 0.1,
            emissive: 0x2d5016,
            emissiveIntensity: 0.2
        });
        
        for (let i = 0; i < 10; i++) {
            const mushroom = new THREE.Mesh(
                new THREE.ConeGeometry(0.3 + Math.random() * 0.5, 1 + Math.random() * 1, 6),
                mushroomMaterial
            );
            mushroom.position.set(
                (Math.random() - 0.5) * 25,
                0.5,
                (Math.random() - 0.5) * 25
            );
            mushroom.rotation.set(
                (Math.random() - 0.5) * 0.2,
                Math.random() * Math.PI * 2,
                (Math.random() - 0.5) * 0.2
            );
            mushroom.castShadow = true;
            mushroom.receiveShadow = true;
            mainWorldGroup.add(mushroom);
        }

        // --- LOW-POLY PERSON CHARACTER ---
        const personGroup = new THREE.Group();
        
        // Low-poly person material for night theme
        const personMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x6b7280,
            metalness: 0.2,
            roughness: 0.7
        });
        
        // Head
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.4, 8, 6),
            personMaterial
        );
        head.position.y = 1.2;
        head.castShadow = true;
        personGroup.add(head);
        
        // Body
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 1.0, 0.4),
            personMaterial
        );
        body.position.y = 0.3;
        body.castShadow = true;
        personGroup.add(body);
        
        // Arms
        const armMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffb366,
            metalness: 0.1,
            roughness: 0.8
        });
        
        const leftArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            armMaterial
        );
        leftArm.position.set(-0.5, 0.2, 0);
        leftArm.castShadow = true;
        personGroup.add(leftArm);
        
        const rightArm = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            armMaterial
        );
        rightArm.position.set(0.5, 0.2, 0);
        rightArm.castShadow = true;
        personGroup.add(rightArm);
        
        // Legs
        const legMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x4a4a4a,
            metalness: 0.1,
            roughness: 0.8
        });
        
        const leftLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            legMaterial
        );
        leftLeg.position.set(-0.2, -0.6, 0);
        leftLeg.castShadow = true;
        personGroup.add(leftLeg);
        
        const rightLeg = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            legMaterial
        );
        rightLeg.position.set(0.2, -0.6, 0);
        rightLeg.castShadow = true;
        personGroup.add(rightLeg);
        
        // Eyes
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), eyeMaterial);
        leftEye.position.set(-0.1, 1.3, 0.3);
        personGroup.add(leftEye);
        
        const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), eyeMaterial);
        rightEye.position.set(0.1, 1.3, 0.3);
        personGroup.add(rightEye);
        
        // Store animation references for character
        personGroup.userData = {
            leftArm: leftArm,
            rightArm: rightArm,
            leftLeg: leftLeg,
            rightLeg: rightLeg,
            head: head,
            isMoving: false,
            walkCycle: 0
        };
        
        mainWorldGroup.add(personGroup);
        
        // Floating labels for objects
        const floatingLabels = [];
        
        // Add floating labels to key objects
        const labelObjects = [
            { pos: new THREE.Vector3(-20, 3, -20), text: "WATER" },
            { pos: new THREE.Vector3(0, 3, 0), text: "START" },
            { pos: new THREE.Vector3(15, 3, 10), text: "PROJECTS" }
        ];
        
        labelObjects.forEach(labelData => {
            if (font) {
                const labelGeometry = new TextGeometry(labelData.text, {
                    font: font,
                    size: 0.2,
                    height: 0.05,
                    curveSegments: 8,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.005,
                    bevelOffset: 0,
                    bevelSegments: 3
                });
                
                const labelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x87ceeb,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0x87ceeb,
                    emissiveIntensity: 0.3
                });
                
                const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
                labelGeometry.computeBoundingBox();
                labelMesh.position.copy(labelData.pos);
                labelMesh.position.x -= labelGeometry.boundingBox.max.x * 0.5;
                labelMesh.castShadow = true;
                mainWorldGroup.add(labelMesh);
                
                floatingLabels.push({
                    mesh: labelMesh,
                    baseY: labelData.pos.y,
                    floatSpeed: 0.02 + Math.random() * 0.01
                });
            }
        });

        // --- ENHANCED PARTICLE SYSTEMS ---
        
        // Main floating particles
        const particleCount = 50;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleSizes = new Float32Array(particleCount);
        const particleColors = new Float32Array(particleCount * 3);
        const particleVelocities = [];

        for (let i = 0; i < particleCount; i++) {
            particleVelocities.push(new THREE.Vector3(
                (Math.random() - 0.5) * 0.1, 
                Math.random() * 0.3 + 0.1, 
                (Math.random() - 0.5) * 0.1
            ));
            
            particlePositions[i * 3] = (Math.random() - 0.5) * 40;
            particlePositions[i * 3 + 1] = Math.random() * 10 + 2;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 40;
            particleSizes[i] = Math.random() * 0.4 + 0.1;
            
            // Random colors for variety
            const color = new THREE.Color();
            color.setHSL(0.6 + Math.random() * 0.2, 0.8, 0.6);
            particleColors[i * 3] = color.r;
            particleColors[i * 3 + 1] = color.g;
            particleColors[i * 3 + 2] = color.b;
        }
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
        
        const particles = new THREE.Points(particleGeometry, new THREE.PointsMaterial({
            size: 0.5,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
            vertexColors: true
        }));
        mainWorldGroup.add(particles);
        
        // Star field particles
        const starCount = 100;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);
        
        for (let i = 0; i < starCount; i++) {
            starPositions[i * 3] = (Math.random() - 0.5) * 200;
            starPositions[i * 3 + 1] = Math.random() * 50 + 20;
            starPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
            starSizes[i] = Math.random() * 0.2 + 0.05;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
        
        const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.3,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        }));
        mainWorldGroup.add(stars);
        

        // --- INTERACTIVE BILLBOARDS ---
        const portfolioItems = [];
        const billboardData = [
             { pos: new THREE.Vector3(-15, 2, -10), title: "PORTFOLIO WEBSITE", subtitle: "THREE.JS INTERACTIVE", color: 0x4a90e2, desc: "The very site you are exploring now! Built with Three.js to create an interactive experience.", link: "https://github.com/Terence-lr/Portfolio-site" },
             { pos: new THREE.Vector3(15, 2, 10), title: "JOB TRACKER", subtitle: "FULL-STACK APP", color: 0x8B4513, desc: "A full-stack application to help users track their job applications from start to finish.", link: "https://github.com/Terence-lr/total-job-tracker-" },
             { pos: new THREE.Vector3(0, 2, -20), title: "DISTANCE CONVERTER", subtitle: "UTILITY TOOL", color: 0x778899, desc: "A handy utility tool for converting various units of distance, built with clean UI principles.", link: "https://github.com/Terence-lr/distance-converter" },
             { pos: new THREE.Vector3(0, 2, 20), title: "GITHUB PROFILE", subtitle: "MY PROJECTS", color: 0x5d4a44, desc: "Explore all my other projects and contributions. Let's connect!", link: "https://github.com/Terence-lr" },
        ];
        
        billboardData.forEach(data => {
            const group = new THREE.Group();
            
            // Billboard frame
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a2a, 
                metalness: 0.8, 
                roughness: 0.2 
            });
            
            const frame = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 0.2), frameMaterial);
            frame.position.y = 2;
            frame.castShadow = true;
            frame.receiveShadow = true;
            group.add(frame);
            
            // Billboard screen with reflection
            const screenMaterial = new THREE.MeshStandardMaterial({ 
                color: data.color, 
                metalness: 0.3, 
                roughness: 0.1,
                emissive: data.color,
                emissiveIntensity: 0.2,
                envMapIntensity: 1.0
            });
            
            const screen = new THREE.Mesh(new THREE.BoxGeometry(5.5, 3.5, 0.1), screenMaterial);
            screen.position.y = 2;
            screen.position.z = 0.1;
            group.add(screen);
            
            // 3D Text on billboard
            if (font) {
                const textGeometry = new TextGeometry(data.title, {
                    font: font,
                    size: 0.3,
                    height: 0.1,
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.01,
                    bevelOffset: 0,
                    bevelSegments: 5
                });
                
                const textMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    metalness: 0.8,
                    roughness: 0.2,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.1
                });
                
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textGeometry.computeBoundingBox();
                textMesh.position.x = -textGeometry.boundingBox.max.x * 0.5;
                textMesh.position.y = 2.5;
                textMesh.position.z = 0.2;
                textMesh.castShadow = true;
                group.add(textMesh);
                
                // Subtitle text
                const subtitleGeometry = new TextGeometry(data.subtitle, {
                    font: font,
                    size: 0.15,
                    height: 0.05,
                    curveSegments: 8,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.005,
                    bevelOffset: 0,
                    bevelSegments: 3
                });
                
                const subtitleMesh = new THREE.Mesh(subtitleGeometry, textMaterial);
                subtitleGeometry.computeBoundingBox();
                subtitleMesh.position.x = -subtitleGeometry.boundingBox.max.x * 0.5;
                subtitleMesh.position.y = 1.8;
                subtitleMesh.position.z = 0.2;
                subtitleMesh.castShadow = true;
                group.add(subtitleMesh);
            }
            
            // Billboard stand
            const standMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                metalness: 0.6, 
                roughness: 0.4 
            });
            
            const stand = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 2, 8), standMaterial);
            stand.position.y = 1;
            stand.castShadow = true;
            stand.receiveShadow = true;
            group.add(stand);
            
            // Enhanced glowing light
            const pointLight = new THREE.PointLight(data.color, 4, 25);
            pointLight.position.y = 3;
            group.add(pointLight);
            data.light = pointLight;
            
            // Interactive proximity detection
            data.isInteracting = false;
            data.interactionDistance = 8;
            
            group.position.copy(data.pos);
            mainWorldGroup.add(group);
            portfolioItems.push({ ...data, mesh: group });
        });

        // Add main world to scene
        scene.add(mainWorldGroup);

        // --- START SCREEN TRANSITION (8-bit inspired) ---
        const startScreenOverlay = document.getElementById('start-screen-overlay');
        const enterWorldButton = document.getElementById('enter-world-button');
        
        // Debug: Check if elements exist
        console.log('Start screen overlay:', startScreenOverlay);
        console.log('Enter world button:', enterWorldButton);
        
        // Add loading animation to start screen
        function addLoadingAnimation() {
            const loadingText = document.createElement('div');
            loadingText.id = 'loading-text';
            loadingText.style.cssText = `
                position: absolute;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                color: #87ceeb;
                font-family: 'Courier New', monospace;
                font-size: 1rem;
                text-transform: uppercase;
                letter-spacing: 2px;
                animation: blink 1s infinite;
            `;
            loadingText.textContent = 'Loading...';
            startScreenOverlay.appendChild(loadingText);
            
            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes blink {
                    0%, 50% { opacity: 1; }
                    51%, 100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Remove loading text after 2 seconds
            setTimeout(() => {
                if (loadingText.parentNode) {
                    loadingText.parentNode.removeChild(loadingText);
                }
            }, 2000);
        }
        
        // Start loading animation
        addLoadingAnimation();
        
        if (enterWorldButton) {
            // Add button press animation
            enterWorldButton.addEventListener('mousedown', () => {
                enterWorldButton.style.transform = 'scale(0.95)';
            });
            
            enterWorldButton.addEventListener('mouseup', () => {
                enterWorldButton.style.transform = 'scale(1)';
            });
            
            enterWorldButton.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                console.log('Enter World button clicked!');
                
                // Add button feedback
                enterWorldButton.textContent = 'ENTERING...';
                enterWorldButton.style.background = 'linear-gradient(45deg, #ff6b35, #ff8c42)';
                
                // Small delay for visual feedback
                setTimeout(() => {
                    // Hide start screen overlay
                    startScreenOverlay.classList.add('hidden');
                    console.log('Start screen overlay hidden');
                    
                    // Show main world
                    mainWorldGroup.visible = true;
                    showStartScreen = false;
                    console.log('Main world shown, showStartScreen set to false');
                    
                    // Hide start screen 3D elements
                    startScreenGroup.visible = false;
                    console.log('Start screen 3D elements hidden');
                    
                    // Start the main animation loop
                    animate();
                    console.log('Animation loop started');
                }, 500);
            });
            
            // Also add touch event for mobile
            enterWorldButton.addEventListener('touchend', (event) => {
                event.preventDefault();
                event.stopPropagation();
                console.log('Enter World button touched!');
                
                // Add button feedback
                enterWorldButton.textContent = 'ENTERING...';
                enterWorldButton.style.background = 'linear-gradient(45deg, #ff6b35, #ff8c42)';
                
                // Small delay for visual feedback
                setTimeout(() => {
                    // Hide start screen overlay
                    startScreenOverlay.classList.add('hidden');
                    console.log('Start screen overlay hidden');
                    
                    // Show main world
                    mainWorldGroup.visible = true;
                    showStartScreen = false;
                    console.log('Main world shown, showStartScreen set to false');
                    
                    // Hide start screen 3D elements
                    startScreenGroup.visible = false;
                    console.log('Start screen 3D elements hidden');
                    
                    // Start the main animation loop
                    animate();
                    console.log('Animation loop started');
                }, 500);
            });
        } else {
            console.error('Enter World button not found!');
        }
        
        // Fallback: Add a simple test button if the main one doesn't work
        setTimeout(() => {
            if (!enterWorldButton || !enterWorldButton.addEventListener) {
                console.log('Creating fallback button...');
                const fallbackButton = document.createElement('button');
                fallbackButton.textContent = 'ENTER WORLD (FALLBACK)';
                fallbackButton.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 9999;
                    background: red;
                    color: white;
                    padding: 10px;
                    border: none;
                    cursor: pointer;
                `;
                fallbackButton.onclick = () => {
                    console.log('Fallback button clicked!');
                    startScreenOverlay.classList.add('hidden');
                    mainWorldGroup.visible = true;
                    showStartScreen = false;
                    startScreenGroup.visible = false;
                    animate();
                };
                document.body.appendChild(fallbackButton);
            }
        }, 2000);

        // --- OPTIMIZED MOVEMENT & CONTROL VARIABLES ---
        const moveState = { forward: 0, strafe: 0, up: 0, turn: 0 };
        const fishVelocity = new THREE.Vector3();
        let isBoosting = false;
        const baseSpeed = 10.0;
        const boostMultiplier = 2.5;
        const momentumDamping = 6.0; // More responsive
        const cameraOffset = new THREE.Vector3(0, 4, 12);
        
        // Simplified movement physics for better responsiveness
        let currentSpeed = 0;
        const maxSpeed = 20.0;
        const acceleration = 15.0;
        const deceleration = 20.0;
        
        let lastTouchX = null;
        let lastTouchY = null;
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');

        // --- DESKTOP CONTROLS ---
        document.addEventListener('keydown', (e) => {
            // W = Forward acceleration
            if (e.code === 'KeyW') moveState.forward = 1;
            // S = Backward acceleration (will turn fish around first)
            if (e.code === 'KeyS') moveState.forward = -1;
            // A = Left acceleration
            if (e.code === 'KeyA') moveState.strafe = -1;
            // D = Right acceleration  
            if (e.code === 'KeyD') moveState.strafe = 1;
            // Q = Up movement
            if (e.code === 'KeyQ') moveState.up = 1;
            // E = Down movement
            if (e.code === 'KeyE') moveState.up = -1;
            // Space = Boost
            if (e.code === 'Space') {
                e.preventDefault();
                isBoosting = true;
            }
        });
        document.addEventListener('keyup', (e) => {
            // W/S = Forward/Backward
            if (['KeyW', 'KeyS'].includes(e.code)) moveState.forward = 0;
            // A/D = Left/Right strafe
            if (['KeyA', 'KeyD'].includes(e.code)) moveState.strafe = 0;
            // Q/E = Up/Down
            if (['KeyQ', 'KeyE'].includes(e.code)) moveState.up = 0;
            // Space = Boost
            if (e.code === 'Space') isBoosting = false;
        });
        
        // --- MOBILE CONTROLS ---
        if (isMobile) {
            const upButton = document.getElementById('depth-up-button');
            const downButton = document.getElementById('depth-down-button');
            const boostButton = document.getElementById('boost-button');

            // Joystick Logic
            let isDragging = false;
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDragging = true;
                handleMove(e.touches[0]);
            });
            joystickContainer.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    handleMove(e.touches[0]);
                }
            });
            joystickContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                isDragging = false;
                moveState.forward = 0;
                moveState.turn = 0;
                joystickThumb.style.transform = `translate(-50%, -50%)`;
            });

            function handleMove(touch) {
                const rect = joystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const maxRadius = rect.width / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                if (distance > maxRadius) {
                    deltaX = (deltaX / distance) * maxRadius;
                    deltaY = (deltaY / distance) * maxRadius;
                }

                joystickThumb.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                
                // Map joystick position to movement state
                const angle = Math.atan2(deltaY, deltaX);
                const normalizedDistance = distance / maxRadius;
                moveState.forward = -Math.cos(angle) * normalizedDistance;
                moveState.strafe = Math.sin(angle) * normalizedDistance;
            }

            // Depth Controls
            upButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                moveState.up = 1;
            });
            upButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                moveState.up = 0;
            });
            downButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                moveState.up = -1;
            });
            downButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                moveState.up = 0;
            });
            
            // Boost Button
            boostButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isBoosting = true;
            });
            boostButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                isBoosting = false;
            });

            // Camera drag on a different touch
            document.addEventListener('touchstart', (e) => {
                if(e.touches.length === 1 && !isDragging) {
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                }
            });
            document.addEventListener('touchmove', (e) => {
                if(e.touches.length === 1 && !isDragging) {
                    const deltaX = e.touches[0].clientX - lastTouchX;
                    const deltaY = e.touches[0].clientY - lastTouchY;
                    personGroup.rotation.y -= deltaX * 0.005;
                    personGroup.rotation.x += deltaY * 0.005; // Added vertical camera rotation
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                }
            });
            document.addEventListener('touchend', () => {
                lastTouchX = null;
                lastTouchY = null;
            });
        }
        
        // --- UI PANELS ---
        const portfolioPanel = document.getElementById('portfolio-info-panel');
        const portfolioTitle = document.getElementById('portfolio-title');
        const portfolioDesc = document.getElementById('portfolio-description');
        const portfolioLink = document.getElementById('portfolio-link');
        let activePortfolioItem = null;

        // --- ENHANCED ANIMATION LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // Only animate main world if not on start screen
            if (showStartScreen) {
                // Animate start screen elements
                if (startParticles) startParticles.rotation.y += deltaTime * 0.1;
                if (startBillboardGroup) startBillboardGroup.rotation.y += deltaTime * 0.05;
                if (startPersonGroup) startPersonGroup.rotation.y += deltaTime * 0.2;
                
                // Update shader uniforms
                nightPass.uniforms.time.value = elapsedTime;
                
                composer.render();
                return;
            }

            // --- WASD Character Movement & Physics ---
            const speedMultiplier = isBoosting ? boostMultiplier : 1.0;
            
            const targetSpeed = Math.abs(moveState.forward) * baseSpeed * speedMultiplier;
            
            // Smooth speed transitions for better responsiveness
            if (targetSpeed > currentSpeed) {
                currentSpeed = Math.min(currentSpeed + acceleration * deltaTime, targetSpeed);
            } else {
                currentSpeed = Math.max(currentSpeed - deceleration * deltaTime, targetSpeed);
            }
            
            // Vertical rotation for Q/E controls
            const pitchSpeed = 0.05 * speedMultiplier;
            personGroup.rotation.x -= moveState.up * pitchSpeed;

            // Constrain fish's vertical rotation to avoid flipping
            personGroup.rotation.x = THREE.MathUtils.clamp(personGroup.rotation.x, -Math.PI / 4, Math.PI / 4);

            // WASD movement calculation
            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(personGroup.quaternion);
            const sideVector = new THREE.Vector3(1, 0, 0).applyQuaternion(personGroup.quaternion);

            // Forward/backward movement (W/S)
            const targetVelocity = forwardVector.multiplyScalar(currentSpeed * moveState.forward);
            
            // Left/right strafe movement (A/D)
            targetVelocity.add(sideVector.multiplyScalar(currentSpeed * moveState.strafe));
            
            // Vertical movement (Q/E)
            targetVelocity.y += moveState.up * currentSpeed * 0.7;

            fishVelocity.lerp(targetVelocity, deltaTime * momentumDamping);
            personGroup.position.add(fishVelocity.clone().multiplyScalar(deltaTime));
            
            // --- CHARACTER ANIMATION ---
            const isMoving = targetVelocity.length() > 0.1;
            if (personGroup.userData) {
                personGroup.userData.isMoving = isMoving;
                
                if (isMoving) {
                    personGroup.userData.walkCycle += deltaTime * 8;
                    
                    // Walking animation
                    const walkOffset = Math.sin(personGroup.userData.walkCycle) * 0.3;
                    const armSwing = Math.sin(personGroup.userData.walkCycle) * 0.5;
                    
                    // Leg animation
                    personGroup.userData.leftLeg.rotation.x = walkOffset;
                    personGroup.userData.rightLeg.rotation.x = -walkOffset;
                    
                    // Arm animation
                    personGroup.userData.leftArm.rotation.x = armSwing;
                    personGroup.userData.rightArm.rotation.x = -armSwing;
                    
                    // Head bobbing
                    personGroup.userData.head.position.y = 1.2 + Math.sin(personGroup.userData.walkCycle * 2) * 0.05;
                } else {
                    // Reset to idle position
                    personGroup.userData.leftLeg.rotation.x = THREE.MathUtils.lerp(personGroup.userData.leftLeg.rotation.x, 0, deltaTime * 5);
                    personGroup.userData.rightLeg.rotation.x = THREE.MathUtils.lerp(personGroup.userData.rightLeg.rotation.x, 0, deltaTime * 5);
                    personGroup.userData.leftArm.rotation.x = THREE.MathUtils.lerp(personGroup.userData.leftArm.rotation.x, 0, deltaTime * 5);
                    personGroup.userData.rightArm.rotation.x = THREE.MathUtils.lerp(personGroup.userData.rightArm.rotation.x, 0, deltaTime * 5);
                    personGroup.userData.head.position.y = THREE.MathUtils.lerp(personGroup.userData.head.position.y, 1.2, deltaTime * 5);
                }
            }
            
            // Update speed indicator
            const speedIndicator = document.getElementById('speed-indicator');
            if (speedIndicator) {
                const speed = Math.round(fishVelocity.length() * 10) / 10;
                const boostStatus = isBoosting ? 'ON' : 'OFF';
                speedIndicator.textContent = `Speed: ${speed} | Boost: ${boostStatus}`;
            }

            // Enhanced fin and tail animation
            const movementIntensity = Math.min(fishVelocity.length() / 5, 1);
            const wiggleSpeed = (isBoosting ? 25 : 12) * (0.5 + movementIntensity);
            const wiggleAmplitude = 0.3 + movementIntensity * 0.4;
            
            fishTail.rotation.y = Math.sin(elapsedTime * wiggleSpeed) * wiggleAmplitude;
            fishTail.rotation.z = Math.sin(elapsedTime * wiggleSpeed * 0.7) * wiggleAmplitude * 0.3;
            
            // Side fin animation
            const sideFinSpeed = wiggleSpeed * 0.8;
            sideFinL.rotation.x = Math.sin(elapsedTime * sideFinSpeed) * 0.3;
            sideFinR.rotation.x = Math.sin(elapsedTime * sideFinSpeed + Math.PI) * 0.3;
            
            // Pectoral fin animation
            pectoralFinL.rotation.x = Math.sin(elapsedTime * sideFinSpeed * 1.2) * 0.2;
            pectoralFinR.rotation.x = Math.sin(elapsedTime * sideFinSpeed * 1.2 + Math.PI) * 0.2;
            
            // Dorsal fin animation
            dorsalFin.rotation.z = Math.sin(elapsedTime * wiggleSpeed * 0.5) * 0.15;
            
            // --- Enhanced Bubble Animation ---
            const positions = particles.geometry.attributes.position.array;
            const sizes = particles.geometry.attributes.size.array;
            
            for (let i = 0; i < particleCount; i++) {
                // Floating particle movement
                positions[i * 3] += particleVelocities[i].x * deltaTime;
                positions[i * 3 + 1] += particleVelocities[i].y * deltaTime;
                positions[i * 3 + 2] += particleVelocities[i].z * deltaTime;
                
                // Particle size variation
                sizes[i] = 0.1 + Math.sin(elapsedTime * 1.5 + i) * 0.1;
                
                // Reset particles that have moved too far
                if (positions[i * 3 + 1] > personGroup.position.y + 20) {
                    positions[i * 3] = personGroup.position.x + (Math.random() - 0.5) * 10;
                    positions[i * 3 + 1] = personGroup.position.y - 5;
                    positions[i * 3 + 2] = personGroup.position.z + (Math.random() - 0.5) * 10;
                        
                        // Update velocity based on person movement
                        particleVelocities[i].x = (Math.random() - 0.5) * 0.1;
                        particleVelocities[i].y = Math.random() * 0.3 + 0.1;
                        particleVelocities[i].z = (Math.random() - 0.5) * 0.1;
                    }
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;
            
            // Animate star field
            if (stars) {
                stars.rotation.y += deltaTime * 0.05;
            }
            
            // Animate floating labels
            if (typeof floatingLabels !== 'undefined') {
                floatingLabels.forEach(label => {
                    label.mesh.position.y = label.baseY + Math.sin(elapsedTime * label.floatSpeed) * 0.3;
                    label.mesh.rotation.y += deltaTime * 0.2;
                });
            }
            
            // Animate water ripples
            const ripples = mainWorldGroup.children.filter(child => child.geometry && child.geometry.type === 'RingGeometry');
            ripples.forEach((ripple, index) => {
                ripple.scale.setScalar(0.1 + Math.sin(elapsedTime * 2 + index) * 0.05);
                ripple.rotation.z += deltaTime * 0.5;
            });
            

            // --- Enhanced Billboard Interaction System ---
            portfolioItems.forEach(item => {
                const distance = personGroup.position.distanceTo(item.mesh.position);
                
                if (distance < item.interactionDistance) {
                    if (!item.isInteracting) {
                        item.isInteracting = true;
                        console.log(`Interacting with ${item.title}: ${item.desc}`);
                        
                        // Show project info
                        projectInfo.innerHTML = `
                            <h3>${item.title}</h3>
                            <p>${item.desc}</p>
                            <a href="${item.link}" target="_blank" class="project-link">View Project</a>
                        `;
                        projectInfo.style.display = 'block';
                    }
                    
                    // Enhanced interaction effects
                    item.mesh.rotation.y += deltaTime * 0.5;
                    item.mesh.scale.setScalar(1.0 + Math.sin(elapsedTime * 3) * 0.1);
                    item.mesh.position.y = item.pos.y + Math.sin(elapsedTime * 2 + item.pos.x * 0.1) * 0.5;
                    
                    if(item.light){
                        item.light.intensity = 6 + Math.sin(elapsedTime * 3) * 2;
                        item.light.color.setHSL(0.6 + Math.sin(elapsedTime * 2) * 0.1, 0.8, 0.6);
                    }
                } else {
                    if (item.isInteracting) {
                        item.isInteracting = false;
                        projectInfo.style.display = 'none';
                    }
                    
                    // Normal billboard animation
                    item.mesh.rotation.y += deltaTime * 0.1;
                    item.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), deltaTime * 2);
                    item.mesh.position.y = item.pos.y + Math.sin(elapsedTime * 0.8 + item.pos.x * 0.1) * 0.3;
                    item.mesh.rotation.x = Math.sin(elapsedTime * 0.5 + item.pos.z * 0.1) * 0.05;
                    
                    if(item.light){
                        item.light.intensity = 3 + Math.sin(elapsedTime * 1.5) * 0.8;
                        item.light.color.setHSL(0.6 + Math.sin(elapsedTime * 0.3) * 0.1, 0.8, 0.6);
                    }
                }
            });
            
            // --- Enhanced God Rays Animation ---
            godraysEffect.rotation.y += deltaTime * 0.03;
            godraysEffect.rotation.x = Math.sin(elapsedTime * 0.1) * 0.1;
            
            // --- ADVANCED LIGHTING ANIMATION (Three.js Examples Inspired) ---
            // Animate star lights with color variation
            starLights.forEach((light, index) => {
                light.intensity = 1.2 + Math.sin(elapsedTime * (0.5 + index * 0.2)) * 0.3;
                const hue = (0.6 + Math.sin(elapsedTime * 0.3 + index) * 0.1) % 1.0;
                light.color.setHSL(hue, 0.8, 0.6);
            });
            
            // Animate volumetric light
            volumetricLight.intensity = 2.0 + Math.sin(elapsedTime * 0.4) * 0.5;
            volumetricLight.position.x = Math.sin(elapsedTime * 0.2) * 5;
            volumetricLight.position.z = Math.cos(elapsedTime * 0.2) * 5;
            
            // Animate hemisphere light
            hemisphereLight.intensity = 0.3 + Math.sin(elapsedTime * 0.1) * 0.1;

            // --- Camera Follow Logic ---
            if (!isMobile) {
                // For desktop, the camera is an OrbitControls
                controls.target.copy(personGroup.position);
                controls.update();
            } else {
                // For mobile, the camera is directly attached behind the fish
                const targetCameraPosition = personGroup.position.clone().add(cameraOffset.clone().applyQuaternion(personGroup.quaternion));
                camera.position.lerp(targetCameraPosition, deltaTime * 4.0);
                camera.lookAt(personGroup.position);
            }

            // --- Portfolio Interaction Logic ---
            let closestItem = null;
            let minDistance = 10;
            portfolioItems.forEach(item => {
                const distance = personGroup.position.distanceTo(item.mesh.position);
                if (distance < minDistance) {
                    closestItem = item;
                    minDistance = distance;
                }
            });
            if (closestItem && closestItem !== activePortfolioItem) {
                activePortfolioItem = closestItem;
                portfolioTitle.textContent = closestItem.title;
                portfolioDesc.textContent = closestItem.desc;
                portfolioLink.href = closestItem.link;
                portfolioPanel.classList.add('visible');
            } else if (!closestItem && activePortfolioItem) {
                activePortfolioItem = null;
                portfolioPanel.classList.remove('visible');
            }
            
            // --- PERFORMANCE OPTIMIZATIONS (Frame.js Inspired) ---
            
            // Update LOD system for performance
            updateLOD();
            
            // Performance monitoring
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                
                // Adaptive quality based on performance
                if (fps < 30) {
                    bloomPass.strength = Math.max(0.5, bloomPass.strength - 0.1);
                } else if (fps > 50) {
                    bloomPass.strength = Math.min(2.0, bloomPass.strength + 0.05);
                }
            }
            
            // Update shader uniforms with smooth interpolation
            nightPass.uniforms.time.value = elapsedTime;
            nightPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            
            // Smooth camera transitions (Frame.js inspired)
            if (controls) {
                controls.update();
            }
            
            // Render with post-processing
            composer.render();
        }

        // --- WINDOW RESIZE HANDLER ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- LOADING SCREEN ---
        const loadingScreen = document.getElementById('loading-screen');
        
        // Hide loading screen after a short delay to ensure everything is loaded
        setTimeout(() => {
            loadingScreen.classList.add('hidden');
        }, 1500);

        // Start the animation loop (will show start screen first)
        animate();

        // --- PERFORMANCE MONITORING ---
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            // Only show performance stats in development
            const stats = new THREE.Stats();
            document.body.appendChild(stats.dom);
            stats.dom.style.position = 'absolute';
            stats.dom.style.top = '0px';
            stats.dom.style.left = '0px';
            stats.dom.style.zIndex = '1000';
            
            function updateStats() {
                stats.update();
                requestAnimationFrame(updateStats);
            }
            updateStats();
        }
    </script>
</body>
</html>
